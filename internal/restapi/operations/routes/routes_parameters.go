// Code generated by go-swagger; DO NOT EDIT.

package routes

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewRoutesParams creates a new RoutesParams object
//
// There are no default values defined in the spec.
func NewRoutesParams() RoutesParams {

	return RoutesParams{}
}

// RoutesParams contains all the bound params for the routes operation
// typically these are obtained from a http.Request
//
// swagger:parameters Routes
type RoutesParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*
	  Required: true
	  In: query
	  Collection Format: multi
	*/
	Dst [][]string
	/*
	  Required: true
	  Max Items: 2
	  Min Items: 2
	  In: query
	  Collection Format: csv
	*/
	Src []string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewRoutesParams() beforehand.
func (o *RoutesParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qDst, qhkDst, _ := qs.GetOK("dst")
	if err := o.bindDst(qDst, qhkDst, route.Formats); err != nil {
		res = append(res, err)
	}

	qSrc, qhkSrc, _ := qs.GetOK("src")
	if err := o.bindSrc(qSrc, qhkSrc, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindDst binds and validates array parameter Dst from query.
//
// Arrays are parsed according to CollectionFormat: "multi" (defaults to "csv" when empty).
func (o *RoutesParams) bindDst(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("dst", "query", rawData)
	}
	// CollectionFormat: multi
	dstIC := rawData
	if len(dstIC) == 0 {
		return errors.Required("dst", "query", dstIC)
	}

	var dstIR [][]string
	for i, dstIV := range dstIC {
		// items.CollectionFormat: csv
		dstIIC := swag.SplitByFormat(dstIV, "csv")

		dstISize := int64(len(dstIIC))

		// items.minItems: 2
		if err := validate.MinItems(fmt.Sprintf("%s.%v", "dst", i), "query", dstISize, 2); err != nil {
			return err
		}

		// items.maxItems: 2
		if err := validate.MaxItems(fmt.Sprintf("%s.%v", "dst", i), "query", dstISize, 2); err != nil {
			return err
		}
		if len(dstIIC) > 0 {

			var dstIIR []string
			for ii, dstIIV := range dstIIC {
				dstII := dstIIV

				if err := validate.Pattern(fmt.Sprintf("%s.%v", fmt.Sprintf("%s.%v", "dst", i), ii), "query", dstII, `^[-+]?[0-9]+\.[0-9]+$`); err != nil {
					return err
				}

				dstIIR = append(dstIIR, dstII)
			}

			dstIR = append(dstIR, dstIIR)
		}
	}

	o.Dst = dstIR

	return nil
}

// bindSrc binds and validates array parameter Src from query.
//
// Arrays are parsed according to CollectionFormat: "csv" (defaults to "csv" when empty).
func (o *RoutesParams) bindSrc(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("src", "query", rawData)
	}
	var qvSrc string
	if len(rawData) > 0 {
		qvSrc = rawData[len(rawData)-1]
	}

	// CollectionFormat: csv
	srcIC := swag.SplitByFormat(qvSrc, "csv")
	if len(srcIC) == 0 {
		return errors.Required("src", "query", srcIC)
	}

	var srcIR []string
	for i, srcIV := range srcIC {
		srcI := srcIV

		if err := validate.Pattern(fmt.Sprintf("%s.%v", "src", i), "query", srcI, `^[-+]?[0-9]+\.[0-9]+$`); err != nil {
			return err
		}

		srcIR = append(srcIR, srcI)
	}

	o.Src = srcIR
	if err := o.validateSrc(formats); err != nil {
		return err
	}

	return nil
}

// validateSrc carries on validations for parameter Src
func (o *RoutesParams) validateSrc(formats strfmt.Registry) error {

	srcSize := int64(len(o.Src))

	// minItems: 2
	if err := validate.MinItems("src", "query", srcSize, 2); err != nil {
		return err
	}

	// maxItems: 2
	if err := validate.MaxItems("src", "query", srcSize, 2); err != nil {
		return err
	}
	return nil
}
